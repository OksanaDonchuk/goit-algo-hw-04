# goit-algo-hw-04
**Python. HW 4. Sorting algorithms**

## Завдання 1

Python має дві вбудовані функції сортування: `sorted` і `sort`. Функції сортування Python використовують `Timsort` — гібридний алгоритм сортування, що поєднує в собі сортування злиттям і сортування вставками.

Порівняйте три алгоритми сортування: злиттям, вставками та `Timsort` за часом виконання. Аналіз повинен бути підтверджений емпіричними даними, отриманими шляхом тестування алгоритмів на різних наборах даних. Емпірично перевірте теоретичні оцінки складності алгоритмів, наприклад, сортуванням на великих масивах. Для заміру часу виконання алгоритмів використовуйте модуль timeit.

Покажіть, що поєднання сортування злиттям і сортування вставками робить алгоритм `Timsort` набагато ефективнішим, і саме з цієї причини програмісти, в більшості випадків, використовують вбудовані в Python алгоритми, а не кодують самі. Зробіть висновки.

## Висновки до завдання 1

## Результати

Порівняння трьох алгоритмів сортування — вставками, злиттям та Timsort — за часом виконання на масивах різного розміру:

| Розмір масиву | Insertion Sort | Merge Sort | Timsort   |
| ------------- | -------------- | ---------- | --------- |
| 100           | 0.00021 с      | 0.00011 с  | 0.00001 с |
| 1500          | 0.05309 с      | 0.00220 с  | 0.00019 с |
| 8000          | 1.40778 с      | 0.01748 с  | 0.00084 с |


## Аналіз:
- **Insertion Sort** (Сортування вставками) показало найгірші результати, особливо на великих масивах. Це підтверджує його квадратичну складність O(n²), яка робить його непрактичним для роботи з великими обсягами даних.
- **Merge Sort** (Сортування злиттям) значно швидше, ніж Insertion Sort, і його час виконання зростає стабільніше. Це відповідає його теоретичній складності O(n log n), що робить його ефективним для сортування великих масивів.
- **Timsort** продемонстрував найкращі результати у всіх тестах. Завдяки поєднанню сортування злиттям та вставками, він оптимізований для реальних наборів даних і забезпечує мінімальний час виконання навіть на великих масивах.

## Висновки

Результати підтверджують, що `Timsort` значно ефективніший порівняно з чистими алгоритмами сортування вставками та злиттям, особливо на великих обсягах даних.

Саме тому Python використовує `Timsort` як стандартний алгоритм сортування, адже він поєднує швидкість, адаптивність та ефективність у більшості практичних випадків.

- Якщо необхідно сортувати невеликі обсяги даних, `Merge Sort` залишається хорошим вибором.
- Якщо ж потрібно швидке і стабільне сортування для реальних сценаріїв – `Timsort` є оптимальним рішенням.

## Завдання 2. Необов'язкове

Дано `k` відсортованих списків цілих чисел. Ваше завдання — об'єднати їх у один відсортований список. При виконанні завдання можете опиратися на алгоритм сортування злиттям з конспекту. Реалізуйте функцію `merge_k_lists` , яка приймає на вхід список відсортованих списків та повертає відсортований список.

Приклад очікуваного результату:

lists = [[1, 4, 5], [1, 3, 4], [2, 6]]
merged_list = merge_k_lists(lists)
print("Відсортований список:", merged_list)

Виведення:

Відсортований список: [1, 1, 2, 3, 4, 4, 5, 6]

